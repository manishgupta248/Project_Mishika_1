# reqirements.txt

asgiref==3.8.1
attrs==25.3.0
bleach==6.2.0
diff-match-patch==20241021
Django==5.1.7
django-cors-headers==4.7.0
django-filter==25.1
django-import-export==4.3.7
django-ratelimit==4.1.0
djangorestframework==3.15.2
djangorestframework_simplejwt==5.5.0
drf-spectacular==0.28.0
et_xmlfile==2.0.0
inflection==0.5.1
jsonschema==4.23.0
jsonschema-specifications==2024.10.1
openpyxl==3.1.5
pillow==11.1.0
psycopg2-binary==2.9.10
PyJWT==2.9.0
python-decouple==3.8
PyYAML==6.0.2
referencing==0.36.2
rpds-py==0.23.1
sqlparse==0.5.3
tablib==3.8.0
tzdata==2025.1
uritemplate==4.1.1
webencodings==0.5.1
whitenoise==6.9.0

=====================================================================

# .env
# This file contains environment variables for the Django project.
# Do not commit this file to version control; use .env.example for templates instead.

# Core Security Settings
# SECRET_KEY: Used for cryptographic signing. Generate a unique 50+ char key using a secure random generator.
SECRET_KEY=gxqb^=t$=hm08%r!j*%&358j38i!3s1g4t%^$yp$5=%t&lwmf#
# JWT_SIGNING_KEY: Separate key for JWT signing. Generate a unique 50+ char key.
JWT_SIGNING_KEY=gxqb^=t$=hm08%r!j*%&358j38i!3s1g4t%^$yp$5=%t&lwmf#

# Application Mode
# DEBUG: Set to True for development, False for production. Controls error detail visibility.
DEBUG=True

# Network Settings
# ALLOWED_HOSTS: Comma-separated list of valid hostnames/IPs. Use '*' in development only with caution.
ALLOWED_HOSTS=localhost,127.0.0.1,yourdomain.com

# Database Configuration
# DB_NAME: Name of the PostgreSQL database.
DB_NAME=jcbust_db8
# DB_USER: Database user with appropriate permissions.
DB_USER=manish
# DB_PASSWORD: Secure password for the database user. Use strong, unique passwords.
DB_PASSWORD=abc@123
# DB_HOST: Hostname of the database server (e.g., localhost or an IP).
DB_HOST=localhost
# DB_PORT: Port for database connection (default PostgreSQL port is 5432).
DB_PORT=5432

# CORS Configuration
# CORS_ALLOWED_ORIGINS: Comma-separated list of origins allowed for CORS requests.
CORS_ALLOWED_ORIGINS=http://localhost:3000,http://127.0.0.1:3000,https://yourdomain.com
# Time Zone
# TIME_ZONE: IANA time zone identifier (e.g., 'Asia/Kolkata', 'UTC').
TIME_ZONE=Asia/Kolkata

# Email Configuration (Uncomment and configure for production)
# EMAIL_HOST: SMTP server hostname (e.g., smtp.gmail.com).
#EMAIL_HOST=smtp.gmail.com
# EMAIL_PORT: SMTP server port (587 for TLS, 465 for SSL).
#EMAIL_PORT=587
# EMAIL_HOST_USER: Email address for sending emails.
#EMAIL_HOST_USER=your-email@gmail.com
# EMAIL_HOST_PASSWORD: App-specific password or SMTP password (avoid using personal passwords).
#EMAIL_HOST_PASSWORD=
# DEFAULT_FROM_EMAIL: Default sender email address (e.g., "Your App <your-email@gmail.com>").
#DEFAULT_FROM_EMAIL="Your App <your-email@gmail.com>"

# Production Security Settings (Uncomment and adjust in production)
# CSRF_TRUSTED_ORIGINS: Comma-separated list of trusted origins for CSRF (include subdomains if needed).
#CSRF_TRUSTED_ORIGINS=https://yourdomain.com
# SECURE_SSL_REDIRECT: Redirect all HTTP to HTTPS (True in production).
#SECURE_SSL_REDIRECT=True
# SESSION_COOKIE_SECURE: Use secure cookies over HTTPS only (True in production).
#SESSION_COOKIE_SECURE=True
# CSRF_COOKIE_SECURE: Use secure CSRF cookies over HTTPS only (True in production).
#CSRF_COOKIE_SECURE=True

=====================================================================
# university/settings.py
"""
Django settings for the University project.
Generated and customized for a secure, scalable backend integrated with Next.js.
"""
import os
from pathlib import Path
from decouple import config, Csv
from django.core.exceptions import ImproperlyConfigured
import logging
from datetime import timedelta

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# Logging Configuration
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
)
logger = logging.getLogger(__name__)

# Helper function to raise errors for missing environment variables
def get_env_variable(var_name, default=None, cast=None):
    """
    Retrieve an environment variable with optional default and casting.

    Args:
        var_name (str): Name of the environment variable.
        default: Default value if variable is not set (optional).
        cast: Function to cast the value (e.g., bool, int, Csv) (optional).

    Returns:
        The casted or raw value of the environment variable.

    Raises:
        ImproperlyConfigured: If variable is required and not found.
    """
    try:
        # If a cast is provided, apply it; otherwise, return the raw value
        if cast is not None:
            return config(var_name, default=default, cast=cast)
        return config(var_name, default=default)
    except KeyError:
        if default is None:
            error_msg = f"Set the {var_name} environment variable"
            logger.error(error_msg)
            raise ImproperlyConfigured(error_msg)
        return default

# Core Security Settings
SECRET_KEY = get_env_variable('SECRET_KEY')  # Required, no default
DEBUG = get_env_variable('DEBUG', default='False', cast=bool)
ALLOWED_HOSTS = get_env_variable('ALLOWED_HOSTS', cast=Csv())

# Application Mode
DEBUG = config("DEBUG", default=False, cast=bool)  # Default to False for safety

# Application definition
INSTALLED_APPS = [
    # Django Core Apps
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Third-Party Apps
    'rest_framework',
    'rest_framework_simplejwt',
    'corsheaders',
    'drf_spectacular',
    'rest_framework_simplejwt.token_blacklist',
    'django_filters',
    'import_export',
    # Local Apps
    'accounts.apps.AccountsConfig',
   # 'academics.apps.AcademicsConfig',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'whitenoise.middleware.WhiteNoiseMiddleware',  # For static file serving
    'django.contrib.sessions.middleware.SessionMiddleware',
    "corsheaders.middleware.CorsMiddleware",  # Must be before CommonMiddleware
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'university.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'university.wsgi.application'


# Database Configuration
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': get_env_variable('DB_NAME'),
        'USER': get_env_variable('DB_USER'),
        'PASSWORD': get_env_variable('DB_PASSWORD'),
        'HOST': get_env_variable('DB_HOST'),
        'PORT': get_env_variable('DB_PORT', cast=int),
        'CONN_MAX_AGE': 600,  # Persistent connections for performance
        'OPTIONS': {'connect_timeout': 10},
    }
}


# Password Validation
AUTH_PASSWORD_VALIDATORS = [
    {'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'},
    {'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator'},
    {'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator'},
    {'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator'},
]

# Internationalization
LANGUAGE_CODE = 'en-us'
TIME_ZONE = get_env_variable('TIME_ZONE', default='UTC')
USE_I18N = True
USE_TZ = True   # Enable timezone-aware datetimes



# Static files (CSS, JavaScript, Images)
# Static and Media Files
STATIC_URL = '/static/'
STATIC_ROOT = BASE_DIR / 'staticfiles'
STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'
MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media'

# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# My Additional Settings

# CORS Configuration
CORS_ALLOWED_ORIGINS = get_env_variable('CORS_ALLOWED_ORIGINS', cast=Csv())
CORS_ALLOW_CREDENTIALS = True
CORS_ALLOW_METHODS = ['DELETE', 'GET', 'OPTIONS', 'PATCH', 'POST', 'PUT']
CORS_ALLOW_HEADERS = [
    'accept', 'accept-encoding', 'authorization', 'content-type', 'dnt',
    'origin', 'user-agent', 'x-csrftoken', 'x-requested-with',
]

# Custom User Model
AUTH_USER_MODEL = "accounts.CustomUser"

# REST Framework Configuration
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': ('accounts.authentication.CookieJWTAuthentication',),
    'DEFAULT_SCHEMA_CLASS': 'drf_spectacular.openapi.AutoSchema',
    'DEFAULT_FILTER_BACKENDS': ['django_filters.rest_framework.DjangoFilterBackend'],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10,
    'EXCEPTION_HANDLER': 'university.utils.custom_exception_handler',
    'DEFAULT_THROTTLE_CLASSES': [
        'rest_framework.throttling.AnonRateThrottle',
        'rest_framework.throttling.UserRateThrottle',
    ],
    'DEFAULT_THROTTLE_RATES': {'anon': '100/hour', 'user': '1000/hour'},
    'DEFAULT_RENDERER_CLASSES': ('rest_framework.renderers.JSONRenderer',),
}

# Security Settings
SECURE_SSL_REDIRECT = get_env_variable('SECURE_SSL_REDIRECT', default='False', cast=bool)
SECURE_HSTS_SECONDS = 31536000 if not DEBUG else 0  # 1 year HSTS in production
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True
SECURE_BROWSER_XSS_FILTER = True
SECURE_CONTENT_TYPE_NOSNIFF = True
X_FRAME_OPTIONS = 'DENY'
CSRF_COOKIE_SECURE = get_env_variable('CSRF_COOKIE_SECURE', default='False', cast=bool)
CSRF_COOKIE_HTTPONLY = True
CSRF_COOKIE_SAMESITE = 'Lax' if DEBUG else 'Strict'
SESSION_COOKIE_SECURE = get_env_variable('SESSION_COOKIE_SECURE', default='False', cast=bool)
SESSION_COOKIE_HTTPONLY = True
SESSION_COOKIE_SAMESITE = 'Lax' if DEBUG else 'Strict'
CSRF_TRUSTED_ORIGINS = get_env_variable('CSRF_TRUSTED_ORIGINS', default='', cast=Csv())

# JWT Configuration (for django-rest-framework-simplejwt)
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=1),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),
    'ROTATE_REFRESH_TOKENS': True,
    'BLACKLIST_AFTER_ROTATION': True,
    'UPDATE_LAST_LOGIN': True,
    'ALGORITHM': 'HS256',
    'SIGNING_KEY': get_env_variable('JWT_SIGNING_KEY', default=SECRET_KEY),
    'VERIFYING_KEY': None,
    'AUTH_HEADER_TYPES': ('Bearer',),
    'AUTH_TOKEN_CLASSES': ('rest_framework_simplejwt.tokens.AccessToken',),
    'AUTH_COOKIE': 'access_token',
    'REFRESH_COOKIE': 'refresh_token',
    'AUTH_COOKIE_SECURE': not DEBUG,  # Secure in production
    'AUTH_COOKIE_HTTP_ONLY': True,
    'AUTH_COOKIE_SAMESITE': 'Strict',
}

# API Documentation (DRF Spectacular)
SPECTACULAR_SETTINGS = {
    'TITLE': 'University API',
    'DESCRIPTION': 'API for managing user authentication and academic resources',
    'VERSION': '1.0.0',
    'SERVE_INCLUDE_SCHEMA': True,
    'SECURITY': [{
        'BearerAuth': {
            'type': 'http',
            'scheme': 'bearer',
            'bearerFormat': 'JWT',
        }
    }],
    'SWAGGER_UI_SETTINGS': {
        'deepLinking': True,
        'persistAuthorization': True,
    },
}

# Logging Configuration
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'file': {
            'level': 'INFO',
            'class': 'logging.FileHandler',
            'filename': BASE_DIR / 'logs' / 'django.log',
            'formatter': 'verbose',
        },
        'console': {
            'level': 'INFO',
            'class': 'logging.StreamHandler',
            'formatter': 'verbose',
        },
    },
    'loggers': {
        'django': {
            'handlers': ['file', 'console'],
            'level': 'INFO',
            'propagate': True,
        },
        'accounts': {
            'handlers': ['console', 'file'],
            'level': 'INFO',
            'propagate': False,
        },
    },
}

# Additional Settings
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
SITE_ID = 1

# Email Configuration (Uncomment and configure in production)
# EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
# EMAIL_HOST = get_env_variable('EMAIL_HOST', default='smtp.gmail.com')
# EMAIL_PORT = get_env_variable('EMAIL_PORT', default=587, cast=int)
# EMAIL_USE_TLS = True
# EMAIL_HOST_USER = get_env_variable('EMAIL_HOST_USER')
# EMAIL_HOST_PASSWORD = get_env_variable('EMAIL_HOST_PASSWORD')
# DEFAULT_FROM_EMAIL = get_env_variable('DEFAULT_FROM_EMAIL')

# Health Check
DATABASE_HEALTH_CHECK = True

# Startup Validation
def perform_startup_validation():
    """Validate essential directories and database connection at startup."""
    try:
        os.makedirs(BASE_DIR / 'logs', exist_ok=True)
        os.makedirs(MEDIA_ROOT, exist_ok=True)
        from django.db import connections
        connections['default'].ensure_connection()
    except Exception as e:
        logger.error(f"Startup validation failed: {str(e)}")
        raise

try:
    perform_startup_validation()
except Exception as e:
    raise  # Re-raise to prevent server startup if validation fails

# Pillow Validation
try:
    from PIL import Image
except ImportError:
    logger.error("Pillow is required for image processing.")
    raise ImproperlyConfigured("Install Pillow with 'pip install Pillow'")

=====================================================================
# university/urls.py
"""
Root URL configuration for the University Django project.
Defines the top-level URL patterns and includes app-specific routes.
"""

from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static
from drf_spectacular.views import SpectacularAPIView, SpectacularSwaggerView

# Base URL patterns for the project
urlpatterns = [
    # Admin Interface
    # In production, consider changing to a non-default path (e.g., 'secret-admin/') for obscurity
    path('admin/', admin.site.urls, name='admin'),

    # API Documentation Endpoints
    path('api/schema/', SpectacularAPIView.as_view(), name='schema'),
    path(
        'api/docs/',
        SpectacularSwaggerView.as_view(url_name='schema'),
        name='swagger-ui',
    ),

    # Application Routes
    path(
        'auth/',
        include(('accounts.urls', 'accounts'), namespace='accounts'),
        name='auth-root',
    ),
    # path(
    #     'academic/',
    #     include(('academics.urls', 'academics'), namespace='academic'),
    #     name='academic-root',
    # ),

    # Placeholder for Future Apps
    # Uncomment and configure as new apps are developed
    # path(
    #     'courses/',
    #     include(('courses.urls', 'courses'), namespace='courses'),
    #     name='courses-root',
    # ),
]

# Development Static and Media File Serving
if settings.DEBUG:
    # Serve static files in development mode
    urlpatterns += static(
        settings.STATIC_URL,
        document_root=settings.STATIC_ROOT,
    )
    # Serve media files in development mode
    urlpatterns += static(
        settings.MEDIA_URL,
        document_root=settings.MEDIA_ROOT,
    )

# URL Structure Documentation
"""
URL Patterns Overview:
    - /admin/          : Django admin interface for managing the application
    - /api/schema/     : Endpoint for retrieving the OpenAPI schema
    - /api/docs/       : Swagger UI for interactive API documentation
    - /auth/           : Authentication endpoints (e.g., login, register)
    - /academic/       : Academic-related endpoints (e.g., courses, grades)
    - /courses/        : Future endpoint for course management (placeholder)

Best Practices:
    - In production, use a web server (e.g., Nginx or Apache) to serve static and media files.
    - Avoid exposing predictable admin URLs in production; customize the path for security.
    - Ensure DEBUG=False in production to disable static/media serving via Django.
"""
===================================================================
# university/utils.py
import logging
from rest_framework.views import exception_handler
from rest_framework.exceptions import ValidationError, AuthenticationFailed, PermissionDenied
from django.http import Http404

logger = logging.getLogger(__name__)

def custom_exception_handler(exc, context):
    """
    Custom exception handler to enhance DRF error responses with additional context.
    
    Args:
        exc: The exception raised during request processing.
        context: Dictionary containing request, view, and other context data.
    
    Returns:
        Response object with enriched error data or None if unhandled.
    """
    # Get the default DRF exception handler response
    response = exception_handler(exc, context)
    
    if response is not None:
        # Enrich response data
        error_data = {
            "status_code": response.status_code,
            "error": str(exc),
            "view": str(context.get('view', 'unknown')),
            "method": context['request'].method,
        }
        
        # Customize error messages based on exception type
        if isinstance(exc, ValidationError):
            error_data["message"] = "Invalid input data provided."
            logger.warning(
                f"Validation error in {context['view']} "
                f"(Method: {context['request'].method}): {exc}"
            )
        elif isinstance(exc, AuthenticationFailed):
            error_data["message"] = "Authentication failed. Please check your credentials."
            logger.error(f"Auth error in {context['view']}: {exc}")
        elif isinstance(exc, PermissionDenied):
            error_data["message"] = "You do not have permission to perform this action."
            logger.error(f"Permission denied in {context['view']}: {exc}")
        elif isinstance(exc, Http404):
            error_data["message"] = "Requested resource not found."
            logger.info(f"404 in {context['view']}: {exc}")
        else:
            error_data["message"] = "An unexpected error occurred."
            logger.error(
                f"Unhandled exception in {context['view']} "
                f"(Method: {context['request'].method}): {exc}",
                exc_info=True  # Include stack trace in logs
            )
        
        # Preserve field-specific errors if present (e.g., from ValidationError)
        if isinstance(exc, ValidationError) and hasattr(exc, 'detail'):
            error_data["details"] = exc.detail
        
        response.data = error_data
    
    return response

# Ensure this is registered in settings.py
# REST_FRAMEWORK = {
#     'EXCEPTION_HANDLER': 'university.utils.custom_exception_handler',
# }
=======================================================
# accounts/models.py
"""
Custom user model and manager for the University project.
Extends Django's AbstractUser with email-based authentication and additional fields.
"""

import os
from django.conf import settings
from django.contrib.auth.models import AbstractUser, PermissionsMixin
from django.contrib.auth.base_user import BaseUserManager
from django.core.exceptions import ValidationError
from django.core.validators import RegexValidator
from django.db import models, IntegrityError
from django.utils import timezone
import bleach

class CustomUserManager(BaseUserManager):
    """Custom manager for handling user creation with email-based authentication."""

    def _normalize_fields(self, email, first_name, last_name):
        """
        Normalize email and name fields for consistency.

        Args:
            email (str): User's email address.
            first_name (str): User's first name.
            last_name (str): User's last name.

        Returns:
            tuple: Normalized (email, first_name, last_name).

        Raises:
            ValueError: If any required field is missing or invalid.
        """
        if not email:
            raise ValueError("A valid email address is required.")
        if not first_name:
            raise ValueError("First name is required.")
        if not last_name:
            raise ValueError("Last name is required.")

        return (
            self.normalize_email(email).strip().lower(),
            first_name.strip().title(),
            last_name.strip().title(),
        )

    def create_user(self, email, first_name, last_name, password=None, **extra_fields):
        """
        Create and save a regular user with the given details.

        Args:
            email (str): User's email address.
            first_name (str): User's first name.
            last_name (str): User's last name.
            password (str, optional): User's password.
            **extra_fields: Additional fields for the user model.

        Returns:
            CustomUser: The created user instance.

        Raises:
            ValidationError: If creation fails due to validation or database issues.
        """
        email, first_name, last_name = self._normalize_fields(email, first_name, last_name)
        user = self.model(email=email, first_name=first_name, last_name=last_name, **extra_fields)

        user.set_password(password)
        try:
            user.full_clean()  # Run model validation
            user.save(using=self._db)
            return user
        except IntegrityError as e:
            if "email" in str(e).lower():
                raise ValidationError(f"Email '{email}' is already in use.")
            raise ValidationError(f"Database error during user creation: {str(e)}")
        except ValidationError:
            raise
        except Exception as e:
            raise ValidationError(f"Unexpected error during user creation: {str(e)}")

    def create_superuser(self, email, first_name, last_name, password=None, **extra_fields):
        """
        Create and save a superuser with elevated privileges.

        Args:
            email (str): Superuser's email address.
            first_name (str): Superuser's first name.
            last_name (str): Superuser's last name.
            password (str, optional): Superuser's password.
            **extra_fields: Additional fields for the user model.

        Returns:
            CustomUser: The created superuser instance.

        Raises:
            ValueError: If superuser flags are not set correctly.
        """
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)
        extra_fields.setdefault('is_active', True)
        extra_fields.setdefault('is_email_verified', True)  # Auto-verify superusers

        if extra_fields.get('is_staff') is not True:
            raise ValueError("Superuser must have is_staff=True.")
        if extra_fields.get('is_superuser') is not True:
            raise ValueError("Superuser must have is_superuser=True.")

        return self.create_user(email, first_name, last_name, password, **extra_fields)


def user_profile_pic_path(instance, filename):
    """
    Generate a unique upload path for user profile pictures.

    Args:
        instance (CustomUser): The user instance.
        filename (str): Original filename of the uploaded image.

    Returns:
        str: Path to store the profile picture (e.g., 'profile_pics/user@example.com_YYYYMMDD_HHMMSS.ext').

    Raises:
        ValueError: If email is missing.
    """
    if not instance.email:
        raise ValueError("Email is required to generate profile picture path.")

    ext = filename.rsplit('.', 1)[-1].lower()  # Extract file extension safely
    timestamp = timezone.now().strftime('%Y%m%d_%H%M%S')
    return os.path.join('profile_pics', f"{instance.email}_{timestamp}.{ext}")


def validate_image_size(value):
    """
    Validate that the uploaded image size does not exceed 5MB.

    Args:
        value (File): The uploaded image file.

    Raises:
        ValidationError: If the file size exceeds 5MB.
    """
    MAX_SIZE = 5 * 1024 * 1024  # 5MB in bytes
    if value.size > MAX_SIZE:
        size_mb = value.size / (1024 * 1024)
        raise ValidationError(f"Image size must be under 5MB. Current size: {size_mb:.2f}MB")


def validate_email_domain(value):
    """
    Restrict email domains to prevent use of disposable or blocked domains.

    Args:
        value (str): Email address to validate.

    Raises:
        ValidationError: If the domain is in the blocked list.
    """
    blocked_domains = getattr(settings, 'BLOCKED_EMAIL_DOMAINS', ['example.com', 'test.com'])
    domain = value.split('@')[-1].lower()
    if domain in blocked_domains:
        raise ValidationError(f"Emails from '{domain}' are not permitted.")


class CustomUser(AbstractUser, PermissionsMixin):
    """
    Custom user model replacing username with email as the primary identifier.
    Includes additional fields like role, profile picture, and mobile number.
    """

    # Remove username field as email is the primary identifier
    username = None

    # Core Fields
    email = models.EmailField(
        unique=True,
        max_length=255,
        blank=False,
        null=False,
        db_index=True,
        verbose_name='Email Address',
        help_text='Enter a valid email address.',
        validators=[validate_email_domain],
        error_messages={'unique': 'This email is already registered.'},
    )

    first_name = models.CharField(
        max_length=50,
        blank=False,
        null=False,
        verbose_name='First Name',
        help_text='Enter your first name.',
    )

    last_name = models.CharField(
        max_length=50,
        blank=False,
        null=False,
        verbose_name='Last Name',
        help_text='Enter your last name.',
    )

    mobile_number = models.CharField(
        max_length=13,
        validators=[
            RegexValidator(
                regex=r'^\+91[6-9]\d{9}$',
                message='Enter a valid Indian mobile number (e.g., +919876543210).',
            )
        ],
        blank=True,
        null=True,
        unique=True,
        verbose_name='Mobile Number',
        help_text='Enter a 10-digit Indian mobile number with +91 prefix (e.g., +919876543210).',
    )

    profile_picture = models.ImageField(
        upload_to=user_profile_pic_path,
        blank=True,
        null=True,
        default='profile_pics/default.jpg',
        verbose_name='Profile Picture',
        validators=[validate_image_size],
        help_text='Upload a profile picture (max 5MB).',
    )

    bio = models.TextField(
        max_length=500,
        blank=True,
        null=True,
        verbose_name='Biography',
        help_text='A short bio about yourself (max 500 characters).',
    )

    # Status Fields
    is_email_verified = models.BooleanField(
        default=False,
        verbose_name='Email Verified',
        help_text='Indicates if the email has been verified.',
    )

    date_joined = models.DateTimeField(
        auto_now_add=True,
        verbose_name='Date Joined',
        help_text='Timestamp of user creation.',
    )

    last_updated = models.DateTimeField(
        auto_now=True,
        verbose_name='Last Updated',
        help_text='Timestamp of last user update.',
    )

    is_active = models.BooleanField(
        default=True,
        verbose_name='Active',
        help_text='Designates whether this user account is active.',
    )

    # Role Definition
    ROLE_CHOICES = (
        ('student', 'Student'),
        ('teacher', 'Teacher'),
        ('admin', 'Admin'),
    )
    role = models.CharField(
        max_length=20,
        choices=ROLE_CHOICES,
        default='student',
        verbose_name='Role',
        help_text='User role within the system.',
    )

    # Manager and Authentication Configuration
    objects = CustomUserManager()
    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['first_name', 'last_name']

    class Meta:
        """Metadata for the CustomUser model."""
        ordering = ['email']
        verbose_name = 'User'
        verbose_name_plural = 'Users'
        indexes = [
            models.Index(fields=['email'], name='email_idx'),
            models.Index(fields=['first_name', 'last_name'], name='name_idx'),
            models.Index(fields=['mobile_number'], name='mobile_idx'),
        ]
        constraints = [
            models.UniqueConstraint(
                fields=['mobile_number'],
                condition=models.Q(mobile_number__isnull=False),
                name='unique_mobile_number_if_not_null',
            ),
        ]

    def __str__(self):
        """Return string representation of the user."""
        return self.email

    @property
    def full_name(self):
        """Return the user's full name as a property."""
        return f"{self.first_name} {self.last_name}".strip()

    def clean(self):
        """Sanitize bio field and run parent validation."""
        if self.bio:
            self.bio = bleach.clean(self.bio, tags=['p', 'strong', 'em'], strip=True)
        super().clean()

    def save(self, *args, **kwargs):
        """
        Override save method to normalize fields and manage profile pictures.

        Args:
            *args: Variable length argument list.
            **kwargs: Arbitrary keyword arguments.
        """
        # Normalize fields
        self.email = self.email.strip().lower()
        self.first_name = self.first_name.strip().title()
        self.last_name = self.last_name.strip().title()
        if self.bio:
            self.bio = self.bio.strip()

        # Handle profile picture updates
        if self.pk and 'profile_picture' in self.get_deferred_fields():
            try:
                old_user = CustomUser.objects.get(pk=self.pk)
                if (
                    old_user.profile_picture
                    and old_user.profile_picture != self.profile_picture
                    and old_user.profile_picture != 'profile_pics/default.jpg'
                    and os.path.isfile(old_user.profile_picture.path)
                ):
                    os.remove(old_user.profile_picture.path)
            except CustomUser.DoesNotExist:
                pass  # Handle case where old instance is missing gracefully

        # Validate default profile picture existence
        default_path = os.path.join(settings.MEDIA_ROOT, 'profile_pics', 'default.jpg')
        if not self.profile_picture and not os.path.exists(default_path):
            raise ValidationError("Default profile picture 'profile_pics/default.jpg' is missing.")

        super().save(*args, **kwargs)
=======================================================================
# accounts/serializers.py
"""
Serializers for the accounts app, handling user data, registration, login, and password changes.
Aligned with CustomUser model and Django REST Framework Simple JWT settings.
"""

import re
from rest_framework import serializers
from django.contrib.auth import get_user_model
from .models import CustomUser

User = get_user_model()  # Use a more generic name for clarity

class UserSerializer(serializers.ModelSerializer):
    """Serializer for retrieving and updating CustomUser details."""
    full_name = serializers.ReadOnlyField(source='get_full_name')  # Explicitly map to property

    class Meta:
        model = User
        fields = [
            'email', 'first_name', 'last_name', 'full_name', 'mobile_number',
            'profile_picture', 'bio', 'role', 'is_email_verified',
            'date_joined', 'last_updated',
        ]
        read_only_fields = [
            'email', 'full_name', 'role', 'is_email_verified',
            'date_joined', 'last_updated',
        ]

    def validate(self, data):
        """
        Prevent updates to read-only fields.

        Args:
            data (dict): Data to validate.

        Returns:
            dict: Validated data.

        Raises:
            serializers.ValidationError: If read-only fields are included in update.
        """
        if self.instance and any(field in data for field in self.Meta.read_only_fields):
            raise serializers.ValidationError({
                'error': 'Cannot modify read-only fields.',
                'read_only_fields': self.Meta.read_only_fields,
            })
        return data


class RegisterSerializer(serializers.ModelSerializer):
    """Serializer for registering a new CustomUser."""
    password = serializers.CharField(
        write_only=True,
        min_length=8,
        help_text='Password must be at least 8 characters with a number and special character.',
    )

    class Meta:
        model = User
        fields = [
            'email', 'first_name', 'last_name', 'password', 'mobile_number',
            'profile_picture', 'bio',
        ]
        extra_kwargs = {
            'email': {'required': True},
            'first_name': {'required': True},
            'last_name': {'required': True},
        }

    def validate_email(self, value):
        """
        Ensure email is unique and normalized.

        Args:
            value (str): Email to validate.

        Returns:
            str: Normalized email.

        Raises:
            serializers.ValidationError: If email is already in use.
        """
        email = value.lower()
        if User.objects.filter(email=email).exists():
            raise serializers.ValidationError("This email is already registered.")
        return email

    def validate_password(self, value):
        """
        Enforce password complexity requirements.

        Args:
            value (str): Password to validate.

        Returns:
            str: Validated password.

        Raises:
            serializers.ValidationError: If complexity rules are not met.
        """
        if not re.search(r'[0-9]', value) or not re.search(r'[!@#$%^&*]', value):
            raise serializers.ValidationError(
                "Password must include at least one number and one special character (!@#$%^&*)."
            )
        return value

    def create(self, validated_data):
        """
        Create a new user using the CustomUserManager.

        Args:
            validated_data (dict): Validated data for user creation.

        Returns:
            User: The created user instance.
        """
        return User.objects.create_user(**validated_data)


class ChangePasswordSerializer(serializers.Serializer):
    """Serializer for changing a user's password."""
    old_password = serializers.CharField(
        write_only=True,
        help_text='Current password for verification.',
    )
    new_password = serializers.CharField(
        write_only=True,
        min_length=8,
        help_text='New password (min 8 chars, with number and special character).',
    )

    def validate_old_password(self, value):
        """
        Verify the current password.

        Args:
            value (str): Old password to check.

        Returns:
            str: Validated old password.

        Raises:
            serializers.ValidationError: If old password is incorrect.
        """
        if not self.context['request'].user.check_password(value):
            raise serializers.ValidationError("Incorrect current password.")
        return value

    def validate_new_password(self, value):
        """
        Enforce complexity for the new password.

        Args:
            value (str): New password to validate.

        Returns:
            str: Validated new password.

        Raises:
            serializers.ValidationError: If complexity rules are not met.
        """
        if not re.search(r'[0-9]', value) or not re.search(r'[!@#$%^&*]', value):
            raise serializers.ValidationError(
                "New password must include at least one number and one special character (!@#$%^&*)."
            )
        return value

    def validate(self, data):
        """
        Ensure new password differs from old.

        Args:
            data (dict): Data containing old and new passwords.

        Returns:
            dict: Validated data.

        Raises:
            serializers.ValidationError: If new password matches old.
        """
        if data['old_password'] == data['new_password']:
            raise serializers.ValidationError("New password must be different from the old password.")
        return data

    def update(self, instance, validated_data):
        """
        Update the user's password.

        Args:
            instance (User): User instance to update.
            validated_data (dict): Validated data with new password.

        Returns:
            User: Updated user instance.
        """
        instance.set_password(validated_data['new_password'])
        instance.save()
        return instance


class LoginSerializer(serializers.Serializer):
    """Serializer for user login."""
    email = serializers.EmailField(
        help_text='Email address used for login.',
    )
    password = serializers.CharField(
        write_only=True,
        help_text='Password for authentication.',
    )
===============================================================
# accounts/views.py
"""
API views for user authentication and profile management in the accounts app.
Uses JWT tokens stored in HTTP-only cookies, aligned with settings.SIMPLE_JWT.
"""

import logging
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated, AllowAny
from rest_framework import status
from rest_framework_simplejwt.tokens import RefreshToken, TokenError
from django.contrib.auth import authenticate
from django.conf import settings
from django.middleware.csrf import get_token
from .serializers import (
    UserSerializer, RegisterSerializer, LoginSerializer, ChangePasswordSerializer,
)

logger = logging.getLogger(__name__)

class BaseTokenView(APIView):
    """Base class for views handling JWT token cookies."""

    def _set_tokens_in_cookies(self, response, refresh):
        """
        Set access and refresh tokens in HTTP-only cookies.

        Args:
            response (Response): DRF Response object to modify.
            refresh (RefreshToken): JWT refresh token instance.
        """
        secure = not settings.DEBUG  # Secure cookies in production
        access_lifetime = settings.SIMPLE_JWT['ACCESS_TOKEN_LIFETIME'].total_seconds()
        refresh_lifetime = settings.SIMPLE_JWT['REFRESH_TOKEN_LIFETIME'].total_seconds()

        response.set_cookie(
            key=settings.SIMPLE_JWT['AUTH_COOKIE'],
            value=str(refresh.access_token),
            httponly=True,
            secure=secure,
            samesite='Strict',
            max_age=int(access_lifetime),
        )
        response.set_cookie(
            key=settings.SIMPLE_JWT['REFRESH_COOKIE'],
            value=str(refresh),
            httponly=True,
            secure=secure,
            samesite='Strict',
            max_age=int(refresh_lifetime),
        )


class RegisterView(BaseTokenView):
    """View for registering a new user and issuing JWT tokens."""
    def post(self, request):
        """
        Handle user registration.

        Args:
            request (Request): HTTP request with user data.

        Returns:
            Response: Success message and user data with tokens in cookies.
        """
        serializer = RegisterSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user = serializer.save()
        refresh = RefreshToken.for_user(user)

        response = Response(
            {'message': 'Registration successful', 'user': UserSerializer(user).data},
            status=status.HTTP_201_CREATED,
        )
        self._set_tokens_in_cookies(response, refresh)
        logger.info(f"User registered: {user.email}")
        return response


class LoginView(BaseTokenView):
    """View for user login and issuing JWT tokens."""
    def post(self, request):
        """
        Handle user login.

        Args:
            request (Request): HTTP request with email and password.

        Returns:
            Response: Success message and user data, or error if credentials are invalid.
        """
        serializer = LoginSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user = authenticate(
            email=serializer.validated_data['email'].lower(),
            password=serializer.validated_data['password'],
        )
        if not user:
            return Response(
                {'error': 'Invalid email or password'},
                status=status.HTTP_401_UNAUTHORIZED,
            )

        refresh = RefreshToken.for_user(user)
        response = Response(
            {'message': 'Login successful', 'user': UserSerializer(user).data},
            status=status.HTTP_200_OK,
        )
        self._set_tokens_in_cookies(response, refresh)
        logger.info(f"User logged in: {user.email}")
        return response


class LogoutView(APIView):
    permission_classes = [AllowAny]

    def post(self, request):
        try:
            # Safely handle request.data
            refresh_token = None
            if request.data is not None:
                refresh_token = request.data.get("refresh")
            if refresh_token:
                token = RefreshToken(refresh_token)
                token.blacklist()
                logger.info(f"Refresh token blacklisted for IP: {request.META.get('REMOTE_ADDR')}")
            else:
                logger.info(f"Logout request without refresh token from IP: {request.META.get('REMOTE_ADDR')}")
            return Response({"message": "Logged out successfully"}, status=200)
        except Exception as e:
            logger.error(f"Logout error: {str(e)}")
            # Still return success, as logout intent is clear
            return Response({"message": "Logged out successfully"}, status=200)


class UserProfileView(APIView):
    """View for retrieving and updating user profile."""
    permission_classes = [IsAuthenticated]

    def get(self, request):
        """
        Retrieve authenticated user's profile.

        Args:
            request (Request): HTTP request.

        Returns:
            Response: User profile data.
        """
        serializer = UserSerializer(request.user)
        return Response(serializer.data, status=status.HTTP_200_OK)

    def post(self, request):
        """
        Update authenticated user's profile.

        Args:
            request (Request): HTTP request with updated profile data.

        Returns:
            Response: Updated user profile data.
        """
        serializer = UserSerializer(request.user, data=request.data, partial=True)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        logger.info(f"Profile updated for user: {request.user.email}")
        return Response(serializer.data, status=status.HTTP_200_OK)


class ChangePasswordView(APIView):
    """View for changing a user's password and invalidating existing tokens."""
    permission_classes = [IsAuthenticated]

    def post(self, request):
        """
        Handle password change and logout.

        Args:
            request (Request): HTTP request with old and new passwords.

        Returns:
            Response: Success message with cleared cookies.
        """
        serializer = ChangePasswordSerializer(data=request.data, context={'request': request})
        serializer.is_valid(raise_exception=True)
        serializer.update(request.user, serializer.validated_data)

        refresh_token = request.COOKIES.get(settings.SIMPLE_JWT['REFRESH_COOKIE'])
        if refresh_token:
            try:
                RefreshToken(refresh_token).blacklist()
            except TokenError as e:
                logger.warning(f"Failed to blacklist refresh token: {str(e)}")

        response = Response(
            {'message': 'Password changed successfully'},
            status=status.HTTP_200_OK,
        )
        response.delete_cookie(settings.SIMPLE_JWT['AUTH_COOKIE'])
        response.delete_cookie(settings.SIMPLE_JWT['REFRESH_COOKIE'])
        logger.info(f"Password changed for user: {request.user.email}")
        return response


class TokenRefreshView(APIView):
    """View for refreshing JWT access tokens using cookies."""
    permission_classes = [AllowAny]  # No authentication required

    def post(self, request):
        """
        Refresh access token using refresh token from cookies.

        Args:
            request (Request): HTTP request with refresh token in cookies.

        Returns:
            Response: New access token in cookies or error if refresh fails.
        """
        refresh_token = request.COOKIES.get(settings.SIMPLE_JWT['REFRESH_COOKIE'])
        if not refresh_token:
            logger.warning("No refresh token provided in request")
            return Response(
                {'error': 'Refresh token is required'},
                status=status.HTTP_400_BAD_REQUEST,
            )

        try:
            # Validate and use the provided refresh token
            token = RefreshToken(refresh_token)
            access_token = str(token.access_token)
            
            # Prepare response
            response = Response(
                {'message': 'Token refreshed successfully'},
                status=status.HTTP_200_OK,
            )
            secure = not settings.DEBUG
            access_lifetime = settings.SIMPLE_JWT['ACCESS_TOKEN_LIFETIME'].total_seconds()

            # Set new access token in cookie
            response.set_cookie(
                key=settings.SIMPLE_JWT['AUTH_COOKIE'],
                value=access_token,
                httponly=True,
                secure=secure,
                samesite='Strict',
                max_age=int(access_lifetime),
            )

            # Handle token rotation if enabled
            if settings.SIMPLE_JWT['ROTATE_REFRESH_TOKENS']:
                # Blacklist the old refresh token
                token.blacklist()
                # Generate a new refresh token without requiring request.user
                new_refresh = RefreshToken()
                refresh_lifetime = settings.SIMPLE_JWT['REFRESH_TOKEN_LIFETIME'].total_seconds()
                response.set_cookie(
                    key=settings.SIMPLE_JWT['REFRESH_COOKIE'],
                    value=str(new_refresh),
                    httponly=True,
                    secure=secure,
                    samesite='Strict',
                    max_age=int(refresh_lifetime),
                )
                logger.info(f"Token rotated and refreshed for IP: {request.META.get('REMOTE_ADDR')}")
            else:
                logger.info(f"Token refreshed for IP: {request.META.get('REMOTE_ADDR')}")

            return response
        except TokenError as e:
            logger.error(f"Token refresh failed: {str(e)}")
            return Response(
                {'error': 'Invalid or expired refresh token'},
                status=status.HTTP_401_UNAUTHORIZED,
            )
        except Exception as e:
            logger.error(f"Unexpected error during token refresh: {str(e)}")
            return Response(
                {'error': 'An unexpected error occurred'},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR,
            )
        
class CSRFView(APIView):
    permission_classes = [AllowAny]
    def get(self, request):
        return Response({"csrfToken": get_token(request)})
============================================================================
# accounts/urls.py
"""
URL configuration for the accounts app.
Defines endpoints for authentication and user profile management.
"""

from django.urls import path
from .views import (
    RegisterView, LoginView, LogoutView,
    UserProfileView, ChangePasswordView, TokenRefreshView,
)

app_name = 'accounts'  # Namespace for URL reversing

urlpatterns = [
    path(
        'register/',
        RegisterView.as_view(),
        name='register',
    ),
    path(
        'login/',
        LoginView.as_view(),
        name='login',
    ),
    path(
        'logout/',
        LogoutView.as_view(),
        name='logout',
    ),
    path(
        'me/',
        UserProfileView.as_view(),
        name='user_profile',
    ),
    path(
        'password/change/',
        ChangePasswordView.as_view(),
        name='change_password',
    ),
    path(
        'token/refresh/',
        TokenRefreshView.as_view(),
        name='token_refresh',
    ),
]

"""
URL Patterns Overview:
    - auth/register/        : Register a new user
    - auth/login/           : Login and obtain JWT tokens
    - auth/logout/          : Logout and blacklist refresh token
    - auth/me/              : Get or update user profile
    - auth/password/change/ : Change user password
    - auth/token/refresh/   : Refresh JWT access token
"""
======================================================================
# accounts/authentication.py
"""
Custom JWT authentication class for the accounts app.
Authenticates users using tokens stored in HTTP-only cookies, with optional header fallback.
"""

import logging
from rest_framework_simplejwt.authentication import JWTAuthentication
from rest_framework_simplejwt.exceptions import InvalidToken, AuthenticationFailed
from django.utils.translation import gettext_lazy as _
from django.contrib.auth import get_user_model
from django.conf import settings

logger = logging.getLogger(__name__)

class CookieJWTAuthentication(JWTAuthentication):
    """
    Custom authentication class extending JWTAuthentication.
    Prioritizes token retrieval from cookies, with fallback to headers if enabled.
    """

    def authenticate(self, request):
        """
        Authenticate a request using a JWT token from cookies or headers.

        Args:
            request (Request): The incoming HTTP request.

        Returns:
            tuple: (user, validated_token) if authentication succeeds, None if no token is provided.

        Raises:
            AuthenticationFailed: If token is invalid, user is inactive, or other errors occur.
        """
        # Retrieve token from cookie (primary method)
        raw_token = request.COOKIES.get(settings.SIMPLE_JWT['AUTH_COOKIE'])

        # Fallback to header if cookie is empty and header auth is enabled
        if not raw_token and getattr(settings, 'ALLOW_HEADER_AUTH', False):
            header = self.get_header(request)
            if header:
                raw_token = self.get_raw_token(header)

        # If no token is found, return None (unauthenticated)
        if not raw_token:
            logger.debug("No JWT token found in cookies or headers.")
            return None

        try:
            # Validate the token
            validated_token = self.get_validated_token(raw_token)
            user = self.get_user(validated_token)

            # Check if user is active
            if not user.is_active:
                logger.warning(f"Authentication failed: Inactive user '{user.email}'.")
                raise AuthenticationFailed(
                    _("User account is disabled."),
                    code='user_inactive',
                )

            logger.debug(f"User authenticated successfully: {user.email}")
            return (user, validated_token)

        except InvalidToken as e:
            logger.warning(f"Invalid token provided: {str(e)}")
            raise AuthenticationFailed(
                _("Invalid or expired token."),
                code='invalid_token',
            )
        except get_user_model().DoesNotExist:
            logger.error("User associated with token not found.")
            raise AuthenticationFailed(
                _("User not found."),
                code='user_not_found',
            )
        except Exception as e:
            logger.error(f"Unexpected authentication error: {str(e)}")
            raise AuthenticationFailed(
                _("Authentication failed due to an unexpected error."),
                code='authentication_failed',
            )
==================================================================
# accounts/admin.py
from django.contrib import admin
from django.contrib.auth import get_user_model
from django.contrib.auth.admin import UserAdmin
from import_export import resources, fields
from import_export.admin import ImportExportModelAdmin
from .models import CustomUser

User = get_user_model()

class CustomUserResource(resources.ModelResource):
    """Resource class for CustomUser model for import/export."""

    role = fields.Field(attribute='role', column_name='role')

    class Meta:
        model = CustomUser
        fields = ('id', 'email', 'first_name', 'last_name', 'mobile_number', 'role', 'is_email_verified', 'is_active', 'is_staff', 'is_superuser', 'date_joined', 'last_updated')
        export_order = ('id', 'email', 'first_name', 'last_name', 'mobile_number', 'role', 'is_email_verified', 'is_active', 'is_staff', 'is_superuser', 'date_joined', 'last_updated')
        import_id_fields = ('email',)

    def dehydrate_role(self, user):
        """Export role as the display name instead of the value."""
        return user.get_role_display()

    def before_import_row(self, row, **kwargs):
        """Validate and normalize role before importing."""
        if 'role' in row:
            value = str(row['role']).strip()
            choice_dict = {key: key for key, _ in CustomUser.ROLE_CHOICES}
            display_dict = {display.lower(): key for key, display in CustomUser.ROLE_CHOICES}
            if value in choice_dict:
                row['role'] = value
            elif value.lower() in display_dict:
                row['role'] = display_dict[value.lower()]
            else:
                raise ValueError(f"Invalid role value: {value}. Must be one of {list(choice_dict.keys())} or {list(display_dict.keys())}")

@admin.register(CustomUser)
class CustomUserAdmin(ImportExportModelAdmin, UserAdmin):
    """Admin class for CustomUser model."""
    resource_class = CustomUserResource
    list_display = ('email', 'first_name', 'last_name', 'mobile_number', 'role', 'is_email_verified', 'is_active', 'is_staff', 'is_superuser', 'date_joined', 'last_updated')
    list_filter = ('role', 'is_email_verified', 'is_active', 'is_staff', 'is_superuser')
    search_fields = ('email', 'first_name', 'last_name', 'mobile_number')
    ordering = ('email',)
    fieldsets = (
        (None, {'fields': ('email', 'password')}),
        ('Personal info', {'fields': ('first_name', 'last_name', 'mobile_number', 'profile_picture', 'bio')}),
        ('Permissions', {'fields': ('is_active', 'is_staff', 'is_superuser', 'groups', 'user_permissions')}),
        ('Important dates', {'fields': ('last_login', 'date_joined')}),
        ('Role', {'fields': ('role', 'is_email_verified')}),
    )
    add_fieldsets = (
        (None, {
            'classes': ('wide',),
            'fields': ('email', 'first_name', 'last_name', 'password', 'password2', 'mobile_number', 'role', 'profile_picture', 'bio', 'is_email_verified', 'is_active', 'is_staff', 'is_superuser', 'groups', 'user_permissions'),
        }),
    )
    readonly_fields = ('last_login', 'date_joined', 'last_updated')

    def save_model(self, request, obj, form, change):
        if not change:
            obj.is_email_verified = False # ensure new users are not auto verified.
        super().save_model(request, obj, form, change)
=======================================================================
